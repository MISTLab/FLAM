include "vec2.bzz"
include "string.bzz"
include "table.bzz"
include "queue.bzz"

include "includes/constants.bzz"
include "includes/debug.bzz"
include "includes/eviction.bzz"
include "includes/fitness.bzz"
include "includes/move.bzz"
include "includes/querying/queries.bzz"
include "includes/risk.bzz"
include "includes/routing.bzz"
include "includes/storage.bzz"
include "includes/data.bzz"
include "includes/failure.bzz"
include "includes/logging.bzz"


function init() {
    current_step = 0
    set_leds(0,255,0)
    math.rng.setseed(id)

    init_available_storage()
    init_hop_count()
    init_fitness()
    init_queries()
    init_random_search()

    CSVLogger.update_current_run()
    reliability_logger = CSVLogger.new("hop_count", "reliability.csv", "nb_created_data,nb_lost_data")
    storage_logger = CSVLogger.new("hop_count", "storage.csv", "nb_data")

    if (id == 0) {
        speed_logger = CSVLogger.new("hop_count", "speed.csv", "arrival_time,creation_time")
    }
}

#
# Calls all required loggers to save metrics
# RETURN: nil
#
function log_metrics() {
    storage_logger.write_row({ .0 = size(storage)})
    reliability_logger.write_row({ .0 = get_nb_created_data(), .1 = get_nb_lost_data() })
}

# Executed every time step
function step() {
    if (current_step < EXPERIMENT_LENGTH) {
        broadcast_lowest_hop_count()
        broadcast_fitness_hop_only()


        if (id != 0){
            data_corruption()

            if ((not is_fit_hop_only()) and (neighbors.count() > 0)){
                evict()
            }

            if ((current_step + id) % 10 == 0){
                generate_data()
            }

        }


        log_metrics()
    }

    # Stop robots when experiment is over
    if (current_step == EXPERIMENT_LENGTH) {
        set_wheels(0.0, 0.0)
        set_leds(255, 0, 0)
    }

    current_step = current_step + 1
}

function reset() {
}
 
function destroy() {
}
