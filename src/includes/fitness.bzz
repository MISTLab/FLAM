include "table.bzz"
include "includes/risk.bzz"
include "includes/routing.bzz"
include "includes/storage.bzz"
include "includes/constants.bzz"


FITNESS_TOLERANCE = 1.2  # 120%


max_neighbor_fitness = -1.0
fitness = -1.0
neighbor_fitnesses = {}


function init_fitness() {
    neighbors.listen("fitness", function(vid, value, neighbor_id) {
        neighbor_fitnesses[neighbor_id] = value
    })
}

function update_neighborhood_fitness() {
    connected_robots = {}
    neighbors.foreach(function(neighbor_id, data) {
        connected_robots[neighbor_id] = 1
    })

    to_delete = {}
    foreach(neighbor_fitnesses, function(neighbor_id, data) {
        if (connected_robots[neighbor_id] == nil) {
            to_delete[neighbor_id] = 1
        }
    })
    
    foreach(to_delete, function(neighbor_id, value) {
        neighbor_fitnesses[neighbor_id] = nil
    })
}

function get_fitness() {
    if (id == 0) {
        return INFINITY  # Base station has infinite fitness
    } else if (is_failed()){
        return 0
    }
    
    return get_available_storage() / (get_radiation_intensity() * get_min_hop_count() * STORAGE_CAPACITY) 
}

function get_fitness_hop_only() {
    if (id == 0) {
        return INFINITY  # Base station has infinite fitness
    } else if (is_failed() or get_available_storage() == 0){
        return 0
    }

    return 1 / get_min_hop_count()
}

function get_max_neighbor_fitness() {
    return table.max(neighbor_fitnesses)
}

function get_id_max_neighbor_fitness() {
    return table.maxkey(neighbor_fitnesses)
}

function is_fit() {
    update_neighborhood_fitness()

    return get_fitness() * FITNESS_TOLERANCE > get_max_neighbor_fitness()
}

function is_fit_hop_only() {
    update_neighborhood_fitness()

    return get_fitness_hop_only() * FITNESS_TOLERANCE > get_max_neighbor_fitness()
}

function broadcast_fitness() {
    neighbors.broadcast("fitness", get_fitness())
}
